# File:		code_generation.py - App-code functions imported by `server.py`
# Author:	Ben Mullan 2024 for ((redacted)) 

import os, json, re, datetime;
from . import server_utils;

@staticmethod
def generate_mainpy_from_notebook_cells(_notebook_path, _notebook_ipynb_json, _selected_cells) -> str:
	"""
		Returns the (relative) file path to the generated `*-main.py`
			→ E.g. "./backend/initial-app-code/hr64hgfkur74h.py"
		
		_selected_cells: an array of integers
	"""
	
	_cells_source = ["".join(_notebook_ipynb_json["cells"][_selected_i]["source"]) for _selected_i in _selected_cells];
	
	_appcode_filename = os.path.join(
		server_utils.INITIAL_APPCODE_FOLDER,
		server_utils.get_new_initital_app_code_filename()
	);
	
	open(_appcode_filename, "w").write(
		f"# Generated by notebook-2-app @ {str(datetime.datetime.now())}\n" +
		f"# Based on notebook {_notebook_path}\n\n" +
		"\r\n".join(_cells_source)
	);
	
	return _appcode_filename;


@staticmethod
def reformat_appcode_with_black(_appcode_filepath) -> None:
	""" Reformats the code file, in-place. """
	
	try:
		_subproc_output = server_utils.get_process_output(["python", "-m", "black", _appcode_filepath]);
		if not ("1 file reformatted" in _subproc_output): raise Exception(f"Black code re-formatting may have run unsuccessfully. \n Output: {_subproc_output}");
	except Exception as _e:
		raise Exception(f"Black code-reformatting encountered an error; {str(_e)}");


@staticmethod
def generate_deployment_yaml_file_contents() -> str:
	return """
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# To-do: Replace fields ___LOOKING_LIKE_THIS___ with appropriate values.
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

jobs:
- job: Validation
  pool:
	  name: ___POOL_NAME___
  displayName: Validation

  steps:
	  - task: UsePythonVersion@0
		displayName: Set python version
		inputs:
			versionSpec: 3.9

	  - bash: |
			python3.9 -m pip install plotly==5.19.0 dash==2.15.0 dash-core-components==2.0.0 dash-html-components==2.0.0 dash-table==5.0.0
		displayName: Install development dependencies

	  - bash: |
		  python3.9 -m pip install -r ./requirements.txt
		workingDirectory: $(Build.SourcesDirectory)/
		displayName: Install dependencies

- job: Publishing
  displayName: Publishing
  dependsOn: Validation
  pool:
	  name: ___POOL_NAME___

  steps:
	  - task: CopyFiles@2
		displayName: Copy build files
		inputs:
			SourceFolder: $(Build.SourcesDirectory)
			Contents: |
				/**
			TargetFolder: $(Build.ArtifactStagingDirectory)
			CleanTargetFolder: true
			OverWrite: true

	  - task: PublishBuildArtifacts@1
		displayName: Publish artifact
		inputs:
			pathtoPublish: $(Build.ArtifactStagingDirectory)
			artifactName: drop

- deployment: Deployment
  dependsOn: Publishing
  pool:
	  name: ___POOL_NAME___
  displayName: Deployment
  environment: ___ENVIRONMENT_NAME___
  strategy:
	  runOnce:
		  deploy:
			  steps:

				  - task: DownloadBuildArtifacts@0
					displayName: Download artifact
					inputs:
						buildType: current
						buildVersionToDownload: latest
						downloadType: single
						artifactName: drop
						downloadPath: $(Build.SourcesDirectory)

				  - task: ArchiveFiles@2
					displayName: Archive web-app files
					inputs:
						rootFolderOrFile: $(Build.SourcesDirectory)/drop/
						includeRootFolder: false
						replaceExistingArchive: true
						archiveFile: $(Build.ArtifactStagingDirectory)/$(Build.BuildId).zip

				  - task: AzureWebApp@1
					displayName: Deploy to web-app
					inputs:
						AzureSubscription: '___AZURE_SUBSCRIPTION___'
						appType: webAppLinux
						appName: '___TARGET_APPSERVICE_NAME___'
						package: $(Build.ArtifactStagingDirectory)/$(Build.BuildId).zip
	""";


@staticmethod
def generate_readme_txt_file_contents() -> str:
	return f"""
This app-code was generated from a Databricks' Notebook, by `notebook-2-app` @ {str(datetime.datetime.now())}

To run locally:
- Ensure a Python interpreter is installed on your system
- Install the dependancies from `requirements.txt`
  (Run `pip install -r requirements.txt` in a terminal)
- Run (e.g. double-click, or run in a terminal) the `main.py` file
- To share amongst your team using VS Code Tunnels:
  https://code.visualstudio.com/docs/remote/tunnels

To deploy to an Azure "App-Service" (lightweight web server):
- Get an App-Service created in Azure (ask DSO or IT)
- Provide the `deploy.yml` file, wherewith the application can be deployed
	""";


@staticmethod
def get_appcode_stats_with_radon(_appcode_filepath) -> dict:
	"""
		Run the following radon commands:
			radon raw --json main.py		From which: loc, comments
			radon mi  --json main.py		From which: mi
		
		Return a dict with:
			{ "line_count":, "comment_line_count":, "maintainability_index": }
	"""
	
	try:
		
		# Looks like: {"./backend/initial-app-code/7fkgkbn2c3ptj4at9kq0.py": {"loc": 10, "lloc": 7, "sloc": 6, "comments": 2, "multi": 0, "blank": 2, "single_comments": 2}}
		_radon_raw_json = json.loads(server_utils.get_process_output( ("python -m radon raw --json").split(" ") + [_appcode_filepath] ));
		
		# Looks like: {"./backend/initial-app-code/7fkgkbn2c3ptj4at9kq0.py": {"mi": 100.0, "rank": "A"}}
		_radon_mi_json = json.loads(server_utils.get_process_output( ("python -m radon mi --json").split(" ") + [_appcode_filepath] ));
		
		return {
			"line_count"			: _radon_raw_json [_appcode_filepath] ["loc"],
			"comment_line_count"	: _radon_raw_json [_appcode_filepath] ["comments"],
			"maintainability_index"	: _radon_mi_json  [_appcode_filepath] ["mi"],
		};
	
	except Exception as _e:
		raise Exception(f"Radon code-statistics encountered an error; {str(_e)} \n {_radon_raw_json=} \n {_radon_mi_json=}");


@staticmethod
def get_regex_based_suggestions(_appcode_string) -> list[dict]:
	""" Suggests replacements based on parts of the source matching specific regular-expressions """
	
	_collected_suggestions = [];
	
	# --- 1 ---
	# Replace figure `.show()` with a call to start the Dash Server
	# `_match.group()` looks like e.g. `figure1.show();`
	
	_DASH_SERVER_SOURCE = """
# Replaced <figure>.show() with Dash Server.
# ⚠ Have only one Dash server per application.

import dash;
app = dash.Dash(__name__);

app.layout = dash.html.Div(
    [
        dash.dcc.Markdown("**Application Title Here**"),
        dash.dcc.Graph(figure=%s)
    ]
);

if __name__ == "__main__": app.run(debug=False);
""";
	
	for _match in re.compile(r"\w+\.show\(\);?").finditer(_appcode_string):
		_collected_suggestions.append(
			{
				"message"		: "⚠️ `figure.show()` is not valid for hosted server-applications; replace with a call to the Dash server?",
				"target_range"	: {
					"startLineNumber"	: _appcode_string[:_match.start()].count("\n") + 1,
					"startColumn"		: 0,
					"endLineNumber"		: _appcode_string[:_match.start()].count("\n") + 1,
					"endColumn"			: 100,
				},
				"replacement"	: _DASH_SERVER_SOURCE % _match.group().split(".")[0],
			}
		);
	
	# --- 2 ---
	# Replace hash-like API keys or other secrets, with a dotenv template
	# `_match.group()` looks like e.g. `"dbapi23hkfis8732khfsahalkjdshfi98jd"`
	
	_DOTENV_SOURCE = """
# 👉 Move secrets into a seperate `.env` file!
# ...whose contents looks like:
#     SECRET_ONE=%s
#     SECRET_TWO="my-very-secret-key-here"

import dotenv;
dotenv.load_dotenv("./../secrets.env");

class SECRETS:
    # Use in-place of string-literal secrets, via e.g. `SECRETS.SECRET_ONE()`
    SECRET_ONE	= lambda : os.environ["SECRET_ONE"];
    SECRET_TWO	= lambda : os.environ["SECRET_TWO"];
""";
	
	for _match in re.compile("\"[\w\.\-@_:\?]{25,}\"").finditer(_appcode_string):
		_collected_suggestions.append(
			{
				"message"		: "⚠️ API key or other sensitive access-code/URL potentially detected; replace with secure environment-variable-based system?",
				"target_range"	: {
					"startLineNumber"	: _appcode_string[:_match.start()].count("\n") + 1,
					"startColumn"		: 0,
					"endLineNumber"		: _appcode_string[:_match.start()].count("\n") + 1,
					"endColumn"			: 100,
				},
				"replacement"	: _DOTENV_SOURCE % _match.group(),
			}
		);
	
	# --- 3 ---
	# Replace files being read from the workspace, with a workspace-file-retrieval system.
	# `_match.group()` looks like e.g. `po2_dataframe = pandas.read_csv("/Workspace/Users/ben.mullan@ ((redacted)) .co.uk/powers-of-two.csv");`

	_PULL_WORKSPACE_FILE_SOURCE = """
import io, urllib.request, json;

class secrets:
    # Put the secrets in a separate .env file, and read 'em in...
    DATABRICKS_HOST            = lambda : "DATABRICKS_HOST";
    DATABRICKS_ACCESS_TOKEN    = lambda : "DATABRICKS_ACCESS_TOKEN";


def get_workspace_file_contents(_workspace_file_path):
    '''
        Downloads the raw text file contents,
        from the databricks' workspace file-system.
    
        Eg: get_workspace_file_contents("/Workspace/misc/x-y-series.csv")
    '''
    
    return make_databricks_api_request(
        "/api/2.0/workspace/export",
        json.dumps({{ "path" : _workspace_file_path, "format" : "SOURCE", "direct_download" : "true" }})
    );


def make_databricks_api_request(_api_path, _post_data) -> str:
    '''
        Authenticates and returns the string response
        from the Databricks' API at _api_path.
    '''

    try:

        _url = f"https://{{ secrets.DATABRICKS_HOST() }}{{_api_path}}";

        _request = urllib.request.Request(
            method  = "GET",
            url     = _url,
            data    = _post_data.encode("utf-8")
        );
        
        _request.add_header("Authorization", f"Bearer {{ secrets.DATABRICKS_ACCESS_TOKEN() }}");
        
        _response = urllib.request.urlopen(_request);
        return _response.read().decode("utf-8");
        
    except Exception as _request_exception:
        raise Exception(f"The Databricks API Request failed, with error [{{str(_request_exception)}}]. URL: {{_url}}");


# TODO: Specify correct DATABRICKS_ACCESS_TOKEN in .env file, for above `secrets` class
# Generate access token: https://learn.microsoft.com/en-us/azure/databricks/dev-tools/auth/pat#--azure-databricks-personal-access-tokens-for-workspace-users

{0} = pandas.read_csv(
    io.StringIO( get_workspace_file_contents({1}) ),
    sep = ","
);
""";

	for _match in re.compile(" *\w+ *= *\w+.\w+\(\n? *\"\/Workspace\/.*\"\n? *\);?").finditer(_appcode_string):
		_collected_suggestions.append(
			{
				"message"				: "🛑 Notebook reliant on workspace file; insert code to remotely connect to workspace and retain data-connectivity?",
				"target_range"			: {
					"startLineNumber"	: _appcode_string[:_match.start()].count("\n"),
					"startColumn"		: 0,
					"endLineNumber"		: _appcode_string[:_match.end()].count("\n") + 1,
					"endColumn"			: 100,
				},
				"replacement"			: _PULL_WORKSPACE_FILE_SOURCE.format(
					_match.group().split("=")[0],
					re.search("\".*\"", _match.group()).group()
				),
			}
		);

	return _collected_suggestions;


@staticmethod
def get_pylint_suggestions(_appcode_filepath) -> list[dict]:
	""" Runs `pylint` to generate code remarks """
	
	try:
	
		_pylint_output = server_utils.get_process_output( ("python -m pylint --output-format=json --exit-zero").split(" ") + [_appcode_filepath] );
		
		return [
			{
				"message"		: f"🛈 {_remark['message']}",
				"replacement"	: "",
				"target_range"	: {
					"startLineNumber"	: _remark["line"],
					"startColumn"		: _remark["column"],
					"endLineNumber"		: _remark["endLine"] or _remark["line"],
					"endColumn"			: (int(_remark["endColumn"]) + 1) if (_remark["endColumn"] is not None) else (1000),
				},
			}
			for _remark in json.loads(_pylint_output)
		];
		
	except Exception as _e:
	
		return [{ "message" : f"❌ Couldn't run `pylint` because: {str(_e)}", "target_range" : { "startLineNumber" :0, "startColumn" : 0, "endLineNumber" : 1000, "endColumn" : 1000 }, "replacement" : "" }];


@staticmethod
def get_appcode_suggestions(_appcode_filepath) -> list[dict]:
	"""
		Returns dicts like:
		{ "message" : "⚠️ Remove personal API key", "target_range" : { "startLineNumber" : 4, "startColumn" : 8, "endLineNumber" : 4, "endColumn" : 13 }, "replacement" : "new code" }
	"""
	
	_appcode_string = open(_appcode_filepath).read();
	
	return [
		* get_regex_based_suggestions	(_appcode_string),
		* get_pylint_suggestions		(_appcode_filepath),
	];